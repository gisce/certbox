name: Automated Release

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      bump_type:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major
      skip_publish:
        description: 'Skip PyPI publishing'
        required: false
        default: false
        type: boolean

jobs:
  release:
    runs-on: ubuntu-latest
    if: "!contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[skip release]')"
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.PUB_MASTER_PUSH_TOKEN }}
        
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.11"
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build twine
        
    - name: Determine version bump
      id: version-bump
      run: |
        cat > determine_version.py << 'EOF'
        #!/usr/bin/env python3
        import json
        import sys
        import os
        import subprocess
        
        # Add scripts to path
        sys.path.insert(0, '.github/scripts')
        
        from version_utils import (
            get_current_version, 
            bump_version, 
            validate_pr_consistency, 
            BumpType,
            determine_bump_from_commits,
            parse_conventional_commit
        )
        
        def get_commits_since_last_tag():
            """Get commits since last release tag."""
            try:
                # Get the last tag
                result = subprocess.run(
                    ['git', 'describe', '--tags', '--abbrev=0'], 
                    capture_output=True, text=True, check=True
                )
                last_tag = result.stdout.strip()
                print(f"ðŸ“‹ Last tag: {last_tag}")
                
                # Get commits since last tag
                result = subprocess.run(
                    ['git', 'log', f'{last_tag}..HEAD', '--pretty=format:%s'], 
                    capture_output=True, text=True, check=True
                )
                commits = [line.strip() for line in result.stdout.split('\n') if line.strip()]
                
            except subprocess.CalledProcessError:
                print("ðŸ“‹ No previous tags found, getting all commits")
                # No tags found, get all commits
                result = subprocess.run(
                    ['git', 'log', '--pretty=format:%s'], 
                    capture_output=True, text=True, check=True
                )
                commits = [line.strip() for line in result.stdout.split('\n') if line.strip()]
                
            return commits
        
        # Manual trigger with specific bump type
        if os.environ.get('GITHUB_EVENT_NAME') == 'workflow_dispatch':
            manual_bump = os.environ.get('INPUT_BUMP_TYPE', 'patch')
            print(f"ðŸŽ¯ Manual trigger with bump type: {manual_bump}")
            bump_type = BumpType(manual_bump)
        else:
            # Automatic trigger - analyze commits since last release
            commits = get_commits_since_last_tag()
            
            if not commits:
                print("âš ï¸  No commits found since last release")
                print("skip_release=true")
                with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                    f.write("skip_release=true\n")
                sys.exit(0)
            
            print(f"ðŸ“ Analyzing {len(commits)} commits since last release:")
            for commit in commits:
                parsed = parse_conventional_commit(commit)
                if parsed:
                    commit_type, is_breaking = parsed
                    status = "ðŸ”´ BREAKING" if is_breaking else "ðŸŸ¢"
                    print(f"   {status} {commit_type}: {commit}")
                else:
                    print(f"   ðŸ“ {commit}")
            
            # For automatic releases, we don't have PR labels, so just use commits
            bump_type = determine_bump_from_commits(commits)
        
        # Get current version and calculate new version
        current_version = get_current_version()
        new_version = bump_version(current_version, bump_type)
        
        print(f"ðŸ“¦ Current version: {current_version}")
        print(f"ðŸ“¦ New version: {new_version}")
        print(f"ðŸ“¦ Bump type: {bump_type.value}")
        
        # Set outputs
        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f"current_version={current_version}\n")
            f.write(f"new_version={new_version}\n")
            f.write(f"bump_type={bump_type.value}\n")
            f.write(f"skip_release=false\n")
        EOF
        
        python determine_version.py
      env:
        INPUT_BUMP_TYPE: ${{ github.event.inputs.bump_type }}
        
    - name: Skip release if no changes
      if: steps.version-bump.outputs.skip_release == 'true'
      run: |
        echo "â­ï¸ Skipping release - no changes since last release"
        
    - name: Update version file
      if: steps.version-bump.outputs.skip_release != 'true'
      run: |
        cat > update_version.py << 'EOF'
        #!/usr/bin/env python3
        import sys
        import os
        
        # Add scripts to path
        sys.path.insert(0, '.github/scripts')
        
        from version_utils import update_version_file
        
        new_version = os.environ['NEW_VERSION']
        print(f"ðŸ“ Updating version to {new_version}")
        
        update_version_file(new_version)
        print("âœ… Version file updated")
        EOF
        
        python update_version.py
      env:
        NEW_VERSION: ${{ steps.version-bump.outputs.new_version }}
        
    - name: Generate changelog
      if: steps.version-bump.outputs.skip_release != 'true'
      run: |
        cat > generate_changelog.py << 'EOF'
        #!/usr/bin/env python3
        import sys
        import os
        import subprocess
        
        # Add scripts to path
        sys.path.insert(0, '.github/scripts')
        
        from changelog_utils import ChangelogGenerator
        
        def get_commits_since_last_tag():
            """Get commits since last release tag."""
            try:
                # Get the last tag
                result = subprocess.run(
                    ['git', 'describe', '--tags', '--abbrev=0'], 
                    capture_output=True, text=True, check=True
                )
                last_tag = result.stdout.strip()
                
                # Get commits since last tag
                result = subprocess.run(
                    ['git', 'log', f'{last_tag}..HEAD', '--pretty=format:%s'], 
                    capture_output=True, text=True, check=True
                )
                commits = [line.strip() for line in result.stdout.split('\n') if line.strip()]
                
            except subprocess.CalledProcessError:
                # No tags found, get recent commits
                result = subprocess.run(
                    ['git', 'log', '-10', '--pretty=format:%s'], 
                    capture_output=True, text=True, check=True
                )
                commits = [line.strip() for line in result.stdout.split('\n') if line.strip()]
                
            return commits
        
        new_version = os.environ['NEW_VERSION']
        
        # Get commits for changelog
        commits = get_commits_since_last_tag()
        
        print(f"ðŸ“‹ Generating changelog for version {new_version}")
        print(f"ðŸ“‹ Processing {len(commits)} commits")
        
        # Generate changelog
        generator = ChangelogGenerator()
        
        # Create initial changelog if it doesn't exist
        if not generator.changelog_path.exists():
            print("ðŸ“„ Creating initial changelog")
            generator.write_changelog(generator.create_initial_changelog())
        
        # Update with new version
        new_content = generator.generate_from_commits(commits, new_version)
        generator.write_changelog(new_content)
        
        print("âœ… Changelog updated")
        EOF
        
        python generate_changelog.py
      env:
        NEW_VERSION: ${{ steps.version-bump.outputs.new_version }}
        
    - name: Commit changes
      if: steps.version-bump.outputs.skip_release != 'true'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        # Configure git to use the bypass token for authentication
        git remote set-url origin https://x-access-token:${{ secrets.PUB_MASTER_PUSH_TOKEN }}@github.com/${{ github.repository }}.git
        git add certbox/__init__.py CHANGELOG.md
        git commit -m "chore: release v${{ steps.version-bump.outputs.new_version }} [skip ci]"
        git push
        
    - name: Create release tag
      if: steps.version-bump.outputs.skip_release != 'true'
      run: |
        # Configure git to use the bypass token for authentication
        git remote set-url origin https://x-access-token:${{ secrets.PUB_MASTER_PUSH_TOKEN }}@github.com/${{ github.repository }}.git
        git tag -a "v${{ steps.version-bump.outputs.new_version }}" -m "Release v${{ steps.version-bump.outputs.new_version }}"
        git push origin "v${{ steps.version-bump.outputs.new_version }}"
        
    - name: Build package
      if: steps.version-bump.outputs.skip_release != 'true'
      run: |
        python -m build
        
    - name: Create GitHub Release
      if: steps.version-bump.outputs.skip_release != 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const path = require('path');
          
          // Read changelog to extract release notes
          let releaseNotes = 'Release notes not available';
          try {
            const changelog = fs.readFileSync('CHANGELOG.md', 'utf8');
            const version = process.env.NEW_VERSION;
            
            // Extract the section for this version
            const versionPattern = new RegExp(`## \\[${version}\\].*?(?=\\n## |$)`, 's');
            const match = changelog.match(versionPattern);
            if (match) {
              releaseNotes = match[0].replace(`## [${version}]`, '').trim();
            }
          } catch (error) {
            console.log('Could not read changelog:', error.message);
          }
          
          const { data: release } = await github.rest.repos.createRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag_name: `v${process.env.NEW_VERSION}`,
            name: `v${process.env.NEW_VERSION}`,
            body: releaseNotes,
            draft: false,
            prerelease: false
          });
          
          console.log(`âœ… Created release: ${release.html_url}`);
      env:
        NEW_VERSION: ${{ steps.version-bump.outputs.new_version }}
        
    - name: Publish to PyPI
      if: steps.version-bump.outputs.skip_release != 'true' && github.event.inputs.skip_publish != 'true'
      env:
        TWINE_USERNAME: gisce
        TWINE_PASSWORD: ${{ secrets.PYPI_MASTER_TOKEN }}
      run: |
        if [ -z "$TWINE_PASSWORD" ]; then
          echo "âš ï¸ PYPI_MASTER_TOKEN not set, skipping PyPI publish"
        else
          echo "ðŸ“¦ Publishing to PyPI..."
          python -m twine upload dist/*
          echo "âœ… Published to PyPI"
        fi
        
    - name: Summary
      if: steps.version-bump.outputs.skip_release != 'true'
      run: |
        echo "## ðŸŽ‰ Release Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Version**: ${{ steps.version-bump.outputs.current_version }} â†’ ${{ steps.version-bump.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Bump Type**: ${{ steps.version-bump.outputs.bump_type }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Tag**: v${{ steps.version-bump.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“‹ Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "- GitHub release created with changelog" >> $GITHUB_STEP_SUMMARY
        echo "- Version updated in codebase" >> $GITHUB_STEP_SUMMARY
        if [ -n "${{ secrets.PYPI_MASTER_TOKEN }}" ]; then
          echo "- Package published to PyPI" >> $GITHUB_STEP_SUMMARY
        else
          echo "- ðŸ“¦ PyPI publishing skipped (PYPI_MASTER_TOKEN not configured)" >> $GITHUB_STEP_SUMMARY
        fi